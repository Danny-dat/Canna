rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /***********************
     * PRIVATE: users/{uid}
     * Nur der Besitzer.
     ***********************/
    match /users/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }

    /****************************************
     * PUBLIC: profiles_public/{uid}
     * Eingeloggt: lesen
     * Schreiben: nur Besitzer, whitelisted Felder
     ****************************************/
    match /profiles_public/{uid} {
      allow read: if request.auth != null;

      allow create, update: if request.auth != null
        && request.auth.uid == uid
        && request.resource.data.keys().hasOnly([
             'displayName','photoURL','username',
             'lastLocation','lastActiveAt',
             'createdAt','updatedAt'
           ]);

      // Optional: Typ-Prüfung für lastLocation:
      // && (!('lastLocation' in request.resource.data)
      //     || (request.resource.data.lastLocation.lat is number
      //         && request.resource.data.lastLocation.lng is number))
    }

    /************************************
     * FRIENDS-ONLY: profiles_friends/{uid}
     * Besitzer schreibt, Freunde lesen, wenn in allowed[].
     ************************************/
    match /profiles_friends/{uid} {
      allow read: if request.auth != null
        && (request.auth.uid == uid
            || (resource.data.allowed != null
                && request.auth.uid in resource.data.allowed));

      allow create, update, delete: if request.auth != null
        && request.auth.uid == uid;
    }

    /********************************
     * consumptions/{id}
     * Nur eigene Einträge.
     ********************************/
    match /consumptions/{id} {
      allow read, update, delete: if request.auth != null
        && resource.data.userId == request.auth.uid;

      allow create: if request.auth != null
        && request.resource.data.userId == request.auth.uid;
    }

    /**********************************************
     * notifications/{id}
     * create: nur Sender (senderId == auth.uid)
     * read/update/delete: nur Empfänger (recipientId == auth.uid)
     **********************************************/
    match /notifications/{id} {
      allow create: if request.auth != null
        && request.resource.data.senderId == request.auth.uid;

      allow read, update, delete: if request.auth != null
        && resource.data.recipientId == request.auth.uid;
    }

    /********************************************************
     * friend_requests/{id}
     * create: nur Absender (fromUid == auth.uid, != toUid)
     *         participants MUSS [fromUid, toUid] enthalten
     * update: nur Teilnehmer; from/to/participants UNVERÄNDERT;
     *         'accepted/declined' nur vom Empfänger
     * delete: nur Teilnehmer
     ********************************************************/
    match /friend_requests/{id} {
      // Erstellen
      allow create: if request.auth != null
        && request.resource.data.fromUid == request.auth.uid
        && request.resource.data.fromUid != request.resource.data.toUid
        && request.resource.data.status == 'pending'
        && request.resource.data.participants is list
        && request.resource.data.participants.size() == 2
        && request.resource.data.participants.hasAll([
             request.resource.data.fromUid,
             request.resource.data.toUid
           ]);

      // Lesen: Absender / Empfänger / Teilnehmer
      allow read: if request.auth != null && (
        request.auth.uid == resource.data.fromUid ||
        request.auth.uid == resource.data.toUid ||
        (resource.data.participants != null
         && request.auth.uid in resource.data.participants)
      );

      // Updaten: nur Teilnehmer; from/to/participants unverändert;
      // akzeptieren/ablehnen nur der Empfänger.
      allow update: if request.auth != null
        && (request.auth.uid == resource.data.fromUid
            || request.auth.uid == resource.data.toUid)
        && request.resource.data.fromUid == resource.data.fromUid
        && request.resource.data.toUid == resource.data.toUid
        && request.resource.data.participants == resource.data.participants
        && request.resource.data.keys().hasOnly([
             'fromUid','toUid','participants','status','createdAt','respondedAt'
           ])
        && !(
             (request.resource.data.status in ['accepted','declined'])
             && request.auth.uid != resource.data.toUid
           );

      // Löschen: nur Teilnehmer
      allow delete: if request.auth != null
        && (request.auth.uid == resource.data.fromUid
            || request.auth.uid == resource.data.toUid);
    }

    /************************
     * chats/{chatId}
     ************************/
    // Chats
    match /chats/{chatId} {
      // Erstellen: nur wenn der aktuelle Nutzer Teilnehmer ist
      allow create: if request.auth != null
                    && request.resource.data.participants != null
                    && request.auth.uid in request.resource.data.participants;

      // Lesen/Updaten: nur Teilnehmer
      allow read, update: if request.auth != null
        && request.auth.uid in resource.data.participants;
    }

    // Chat-Nachrichten (Subcollection)
    match /chats/{chatId}/messages/{msgId} {
      // Teilnehmer des Chat-Dokuments dürfen lesen/schreiben
      allow read, create: if request.auth != null
        && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;

      // Update/Löschen – optional restriktiver (z. B. nur Sender)
      allow update, delete: if request.auth != null
        && request.auth.uid in get(/databases/$(database)/documents/chats/$(chatId)).data.participants;
    }

    /***********************
     * presence/{uid}
     * einfacher Online-/Aktivstatus
     ***********************/
    match /presence/{uid} {
      allow read: if request.auth != null; // ggf. später einschränken
      allow create, update: if request.auth != null && request.auth.uid == uid;
    }

    /************************
     * events/{id}
     ************************/
    match /events/{id} {
      allow read: if request.auth != null;
      allow update: if request.auth != null;
      // Optional: Voting-Felder whitelisten:
      // allow update: if request.auth != null
      //   && request.resource.data.diff(resource.data).changedKeys()
      //      .hasOnly(['upvotes','downvotes']);
    }
    match /global_chat/{messageId} {
  allow read: if request.auth != null;
  allow create: if request.auth != null && request.resource.data.senderId == request.auth.uid;
}

    /****************
     * Catch-All
     ****************/
    match /{document=**} {
      allow read, write: if false;
    }
  }
}
